#include <iostream>
int main(void)
{
	//선언시 몇개의 배열을 만들지 명시해야함
	//몇개의 배열을 만들건지 명시하는 부분은 반드시 상수여야함
	//int iTestArr[iData1];

	//선언과 동시에 초기화 및 선언과 초기화 분리

	//1.선언과 초기화 분리
	/*int iArr[5];
	iArr[0] = 0;
	iArr[1] = 0;
	iArr[2] = 0;
	iArr[3] = 0;
	iArr[4] = 0;*/

	//2.선언과 동시에 초기화
	
	//전체 다 0으로 초기화
	int iArr2[5] = {};

	//명시하지 않고 원소넣은 크기대로 크기 지정
	int iArr1[] = { 1,2,3,4,5 };
	//배열의 크기는 원소넣은 크기만큼 정해짐, 1개 넣었으니 다음 배열 크기는 1
	int iArr1[] = { 1,};

	int iArr3[5] = { 1,2,3,4,5 };

	
	//*명시를 생략하면 이후에는 0으로 들어감
	int iArr4[5] = { 1,2, };
	
	//C++11에서 나온 초기화 문법(0으로 초기화)
	int iArr5[5]{};

	

	//iArr2는 시작주소를 저장하고 있음, iArr2=&iArr2[0](배열시작위치의 주소값)
	//따라서, 배열의 이름은 상수 포인터(값 변경이 불가함, 원래갖고있던 배열의 주소값을 잃어버리면 배열에 접근을 못하기 때문에)
	//배열은 연속된 메모리공간에 할당이 됨
	std::cout << iArr2 << std::endl;
	std::cout << &iArr2[0] << std::endl;
	
	int* ptr = nullptr;
	//배열의 이름은 상수포인터라 주소값 변경 불가
	iArr2 = ptr;

	//배열의 포인터연산(+,-만 가능함, *,/연산은 주소값의 이동이 너무 커지기 때문에 잘못된 접근을 할 수 있어서 못하게 막아둠)
	std::cout << &iArr[1] << std::endl;
	//대입연산이 아니라 포인터가 상수여도 연산이 가능
	//std::cout << (iArr + 1) << std::endl;
	//전위증가는 대입연산이 되기때문에 연산불가
	//cout<<++iArr<<std::endl;
	
	//배열의 포인터 연산은 자료형의 크기 기준으로 움직임

	//배열과 달리 변수는 절대로 연속된 메모리공간에 할당이 안됨
	short a1 = 0, short a2 = 0;

	//배열의크기
	int iArrSize[10];
	std::cout << sizeof(iArrSize) << std::endl;

	

}